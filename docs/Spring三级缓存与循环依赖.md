# Spring三级缓存与循环依赖机制总结

## 一、三级缓存核心要点

| 缓存级别 | 名称(Map)               | 存储内容                          | 作用阶段             | 线程安全          | 生命周期 |
| -------- | ----------------------- | --------------------------------- | -------------------- | ----------------- | -------- |
| 一级缓存 | `singletonObjects`      | 完全初始化好的单例Bean            | Bean完全创建后       | ConcurrentHashMap | 长期存在 |
| 二级缓存 | `earlySingletonObjects` | 仅实例化但未初始化的原始Bean      | 解决循环依赖时       | HashMap           | 临时存在 |
| 三级缓存 | `singletonFactories`    | 能生成Bean早期引用的ObjectFactory | Bean实例化后立即放入 | HashMap           | 最短存在 |

## 二、循环依赖解决流程（Setter注入）

1. **创建Bean A**
   - 实例化A（调用构造器）
   - 将A的ObjectFactory放入三级缓存
   - 开始属性填充（发现需要B）

2. **创建Bean B**
   - 实例化B（调用构造器）
   - 将B的ObjectFactory放入三级缓存
   - 开始属性填充（发现需要A）

3. **解决循环依赖**
   - 从三级缓存获取A的ObjectFactory
   - 调用getObject()获取A的早期引用
   - 将A升级到二级缓存
   - 将A注入B
   - B完成初始化，放入一级缓存

4. **完成A的创建**
   - 从一级缓存获取完整的B
   - 将B注入A
   - A完成初始化，放入一级缓存
   - 从二级缓存移除A

## 三、构造器注入为何失败？

1. **根本原因**：实例化阶段就需要依赖对象，而Setter注入是在属性填充阶段才需要

2. **具体表现**：
   - A构造器需要B → 尝试创建BSpringTransactionMechanism.md
   - B构造器需要A → 尝试创建A
   - 形成死循环，无法完成任一Bean的实例化
   - 无法向任何缓存存入对象

3. **Spring处理**：直接抛出`BeanCurrentlyInCreationException`

## 四、三级缓存的设计意义

1. **分离关注点**：
   - 一级缓存：管理完整可用的Bean
   - 二级缓存：暂存半成品Bean
   - 三级缓存：处理Bean的早期引用生成

2. **性能优化**：
   - 确保`SmartInstantiationAwareBeanPostProcessor`只执行一次
   - 避免重复创建代理对象

3. **扩展性支持**：
   - 通过ObjectFactory支持AOP等动态代理
   - 可以插入自定义的Bean处理逻辑

## 五、最佳实践建议

1. **优先使用Setter注入**解决循环依赖
2. **避免构造器注入**的循环依赖（考虑重构设计）
3. **对于必须的循环依赖**：
   - 使用@Lazy延迟加载
   - 引入中间层或事件机制
   - 考虑应用服务层解耦

4. **原型(prototype)Bean**的循环依赖无法解决，需重新设计

## 六、常见误区澄清

1. **误区**：二级缓存可以直接存储Bean实例
   - 事实：二级缓存存储的是经过`getEarlyBeanReference`处理的早期引用

2. **误区**：三级缓存是必须的
   - 事实：理论上可以只有两级缓存，但会牺牲灵活性和性能

3. **误区**：Spring鼓励使用循环依赖
   - 事实：Spring提供了解决方案，但循环依赖通常意味着设计缺陷

通过这种三级缓存机制，Spring在保持高扩展性的同时，优雅地解决了大多数合理的循环依赖场景，体现了框架设计的精妙平衡。