### Redis 全面总结

---

### **一、Redis 核心特性**
1. **单线程模型**：
   - 所有命令串行执行，避免多线程竞争，天然保证单命令的原子性。
   - 高性能依赖内存操作和非阻塞 I/O 多路复用（如 `epoll`）。
   
2. **原子操作**：
   - **单命令原子性**：如 `INCR`、`DECR`、`SET` 等，适用于计数器、库存扣减。
   - **Lua 脚本**：复杂操作可通过 Lua 脚本保证原子性（如组合读写操作）。
   - **事务（WATCH/MULTI/EXEC）**：乐观锁机制，需手动处理冲突和重试。

3. **持久化**：
   - **RDB**：快照持久化，适合备份和恢复。
   - **AOF**：日志追加，更高数据安全性，但性能开销较大。

---

### **二、高并发场景应用：秒杀设计**
1. **核心问题**：
   - 超卖：多个请求同时扣减库存导致负值。
   - 性能瓶颈：高并发下数据库压力。

2. **解决方案**：
   - **原子操作直接扣减**：
     ```redis
     DECR stock_key  # 单命令原子扣减，无需锁
     ```
   - **乐观锁（WATCH + 事务）**：
     ```java
     jedis.watch("stock");
     int stock = Integer.parseInt(jedis.get("stock"));
     if (stock > 0) {
         Transaction tx = jedis.multi();
         tx.decr("stock");
         tx.exec(); // 若冲突则返回 null，需重试
     }
     ```
   - **Lua 脚本**：
     ```lua
     local stock = tonumber(redis.call('GET', KEYS[1]))
     if stock > 0 then
         redis.call('DECR', KEYS[1])
         return 1
     else
         return 0
     end
     ```

3. **优化方向**：
   - 预减库存：库存预热至 Redis，避免直接访问数据库。
   - 限流削峰：结合令牌桶、队列等控制请求流量。
   - 异步处理：扣减成功后，异步更新数据库和发送通知。

---

### **三、Redis 数据类型与使用场景**
#### **1. 5 种基本数据类型**
| **类型**       | **特点**                 | **使用场景**                 | **示例命令**                  |
| -------------- | ------------------------ | ---------------------------- | ----------------------------- |
| **String**     | 字符串、整数、二进制数据 | 缓存、计数器、分布式锁       | `SET`, `GET`, `INCR`          |
| **Hash**       | 键值对集合（对象存储）   | 用户信息、购物车             | `HSET`, `HGET`, `HINCRBY`     |
| **List**       | 有序列表，支持双向操作   | 消息队列、最新记录           | `LPUSH`, `BRPOP`, `LRANGE`    |
| **Set**        | 无序唯一集合             | 标签系统、共同好友、抽奖去重 | `SADD`, `SINTER`, `SISMEMBER` |
| **Sorted Set** | 有序集合（按分数排序）   | 排行榜、延时队列、优先级任务 | `ZADD`, `ZRANGE`, `ZREVRANK`  |

#### **2. 3 种特殊数据类型**
| **类型**        | **特点**                 | **使用场景**           | **示例命令**                     |
| --------------- | ------------------------ | ---------------------- | -------------------------------- |
| **HyperLogLog** | 基数统计（低内存误差率） | 独立访客统计（UV）     | `PFADD`, `PFCOUNT`, `PFMERGE`    |
| **Bitmap**      | 二进制位操作             | 用户签到、活跃用户标记 | `SETBIT`, `GETBIT`, `BITCOUNT`   |
| **Geospatial**  | 地理位置坐标计算         | 附近的人、配送范围查询 | `GEOADD`, `GEODIST`, `GEORADIUS` |

---

### **四、Redis 使用注意事项**
1. **性能优化**：
   - 避免大 Key：单个 Key 的 Value 不宜过大（如超过 1MB）。
   - 批量操作：使用 `Pipeline` 减少网络往返开销。
   - 合理设置过期时间：避免内存泄漏，如 `EXPIRE key 3600`。

2. **数据一致性**：
   - 强一致性场景慎用：Redis 是内存数据库，宕机可能丢数据（需结合持久化策略）。
   - 缓存穿透/雪崩/击穿：通过布隆过滤器、随机过期时间、互斥锁解决。

3. **部署与高可用**：
   - 主从复制：读写分离，提升读性能。
   - 哨兵模式（Sentinel）：自动故障转移，实现高可用。
   - 集群模式（Cluster）：数据分片，支持水平扩展。

---

### **五、常见问题 Q&A**
#### **Q1：Redis 为什么快？**
- 内存操作、单线程无锁竞争、非阻塞 I/O 多路复用。

#### **Q2：Redis 事务为什么不支持回滚？**
- Redis 设计哲学是保持简单高效，错误通常由编程错误导致，需开发者提前规避。

#### **Q3：如何选择 Redis 和数据库？**
- Redis：高频读写、临时数据（如缓存、计数器）。
- 数据库：持久化存储、复杂查询（如订单记录）。

#### **Q4：为什么推荐用 Lua 脚本代替事务？**
- Lua 脚本可保证多个命令的原子性，且无需处理事务冲突和重试逻辑。

---

### **六、总结**
Redis 凭借其高性能、丰富的数据类型和原子操作特性，成为高并发场景的核心组件。合理使用 String 的原子计数、Hash 的对象存储、Sorted Set 的排行榜功能，以及特殊类型的 HyperLogLog 和 Bitmap，可以显著提升系统性能。结合 Watch 事务、Lua 脚本和持久化策略，能在保证数据一致性的同时应对高并发挑战。最终，根据业务场景选择合适的数据类型和架构方案，是 Redis 高效应用的关键。